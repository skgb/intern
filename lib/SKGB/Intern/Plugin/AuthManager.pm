package SKGB::Intern::Plugin::AuthManager;
use Mojo::Base 'Mojolicious::Plugin';

use utf8;

use Mojolicious 7.13;  # Mojo::Message::Response->is_success
use DateTime::Format::ISO8601;
# todo: check out DateTime::Format::RFC3339
use Data::Dumper;

use SKGB::Intern::AccessCode;
use SKGB::Intern::Article;


my $Q = {
  may => <<_,
MATCH (c:AccessCode)-[:IDENTIFIES]->(:Person)-[:ROLE|GUEST*..4]->(r:Role)
WHERE c.code = {code} AND NOT( (c)-[:NOT]->(r) )
RETURN r.role
UNION
MATCH (c:AccessCode)-[:ROLE*..4]->(r:Role)
WHERE c.code = {code}
RETURN r.role
_
  wikiroles => <<_,
MATCH (a:WikiArticle)--(r:Role)
RETURN a.slug AS slug, collect(r.role) AS role
_
  entity_exceptions => <<_,
MATCH (c:AccessCode)-[:IDENTIFIES]->(x:Person)
WHERE c.code = {code}
RETURN CASE WHEN exists(x.userId) THEN x.userId ELSE id(x) END AS handle, head(labels(x)) AS label
UNION
MATCH (c:AccessCode)-[:IDENTIFIES]->(p:Person)-[y:OWNS|:DEBITOR|:HOLDER|:FOR|:PARENT|:COLLECTOR]-(x)
WHERE c.code = {code}
RETURN CASE WHEN exists(x.userId) THEN x.userId ELSE id(x) END AS handle, head(labels(x)) AS label
UNION
MATCH (c:AccessCode)-[:IDENTIFIES]->(q:Person)<-[:PARENT]-(x:Person)
WHERE c.code = {code}
RETURN CASE WHEN exists(x.userId) THEN x.userId ELSE id(x) END AS handle, head(labels(x)) AS label
UNION
MATCH (c:AccessCode)-[:IDENTIFIES]->(q:Person)<-[:PARENT]-(p:Person)-[y:OWNS|:DEBITOR|:HOLDER|:FOR|:PARENT|:COLLECTOR]-(x)
WHERE c.code = {code}
RETURN CASE WHEN exists(x.userId) THEN x.userId ELSE id(x) END AS handle, head(labels(x)) AS label
_
};


our $OPEN_ACCESS = \'open';  # a true value, comparable by ==
our $USER_ACCESS = \'user';  # a true value, comparable by ==
our $NO_ACCESS = ! 1;  # a false value equal to '', yet comparable by ==


sub register {
	my ($self, $app, $args) = @_;
	$args ||= {};
	
	$app->sessions->default_expiration( $app->config->{ttl}->{cookie} );
	$app->sessions->cookie_name('SKGB-intern_Login');
	$app->sessions->secure($app->mode ne 'development');  # production: HTTPS only
	
	# As a rule, none of the responses generated by this application are
	# cacheable because all of them might or might not be personalized,
	# depending upon the session cookie among other things.
	$app->hook(after_dispatch => sub {
		my ($c, $args) = @_;
		# HTTP: RFCs 7231, 7234
		
		# make sure public static files are cacheable
		my $content = $c->res->content;
		if (ref $content eq 'Mojo::Content::Single' && ref $content->asset eq 'Mojo::Asset::File') {
			if ( grep {$content->asset->path =~ m|^$_/|} @{$app->static->paths} ) {
				$c->res->headers->cache_control('public');  # mostly useless
				return;  # very important
			}
		}
		
		# advertise authentication
		# NB: X-Cookie is not a registered new auth scheme and will hopefully remain so; this header should never trigger any kind of special treatment by the user agent
		# see http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml
		# see http://tools.ietf.org/html/draft-broyer-http-cookie-auth-00
		$c->res->headers->www_authenticate('X-Cookie');
		
		if ($app->sessions->default_expiration) {
			# in the current Mojo implementation the cookie includes the ever-changing expiration time, thereby precluding hits while filling up the cache
			$c->res->headers->cache_control('no-cache');
			$c->res->headers->header(Pragma => 'no-cache');  # HTTP/1.0 fallback
		}
		else {
			# session cookies only include the access code, which is static and which primarily decides what gets rendered
			$c->res->headers->vary('Cookie');
			if ($c->skgb->session->user) {
				# 'private' disallows shared caches and 'no-store' disallows storage on disk, leaving nothing but in-memory browser cache (for data protection)
				$c->res->headers->cache_control('private, no-store');
				$c->res->headers->header(Pragma => 'no-cache');  # HTTP/1.0 fallback
			}
			elsif ($c->res->is_success) {
				# 'public' explicitly allows caching, which is useful for public content (except maybe for error pages)
				$c->res->headers->cache_control('public');
			}
		}
	});
	
	my @helpers = qw( link_auth_to auth_link_to );
	$app->helper($_ => __PACKAGE__->can("_$_")) for @helpers;
	
	my @skgb_helpers = qw( session may _may_mojo _may_wiki role auth_link_to _link_url );
	$app->helper("skgb.$_" => __PACKAGE__->can("_$_")) for @skgb_helpers;
	
	$app->helper('skgb.reset_login_fails' => sub { $self->_reset_login_fails(@_); });
	
	$app->helper('reply.forbidden' => sub {
		shift->render(template => 'key_manager/forbidden', status => 403);
		return undef;
	});
	
}


# Get the AccessCode object AKA 'session hash'. A key parameter may be given to
# use that specific key in lieu of the current session; this is required when
# logging in.
# Also sets/refreshes the session cookie. To be called on every access.
sub _session {
	my ($c, $key) = @_;
	$key ||= $c->session('key');
	
	my $session = $c->stash('session');
	if (! $session || $session->code ne $key) {
		$session = SKGB::Intern::AccessCode->new( code => $key, app => $c );
		if ($session->user) {
			$session->update;
			$c->session( expiration => $c->config->{ttl}->{secure} ) if $session->secure;
			$c->session( key => $key );
		}
		$c->stash(session => $session);
	}
	
	return $session;
}


sub _may {
	my ($c, $right, $key, $entity) = @_;
	if (@_ == 1) {
		$right = 'mojo:' . $c->current_route;
		$entity = $c->match->endpoint->pattern->match($c->url_for)->{entity};
	}
#	say "may: $right";
	if ($right =~ m/^(?:mojo:)?wiki([a-z]*)$/) {
		return $c->skgb->_may_wiki($1, $entity, $key);
	}
	return $c->skgb->_may_mojo($right, $key, $entity);
}


sub __may_mojo {
	my ($c, $right, $key, $entity) = @_;
	
	# truth table Mojo access:
	#  E F G => access
	#  0 - - =>  open
	#  - 1 - =>  user
	#  1 0 1 =>  user
	#  1 0 0 =>   no
	# (E) = ROUTE exists in database
	# (F) = USER has role for ROUTE
	# (G) = USER has exception for ENTITY in ROUTE
	
	# (E) workaround; TODO
	if ($right =~ m/^mojo:(.*)$/) {
		my $routes = $c->app->routes;
		my $route = $routes->lookup($1);
		# top level route => no login requirement => public access
		return $OPEN_ACCESS if $route && $route->parent == $routes;
	}
	
	$key ||= $c->session('key');
	return $NO_ACCESS if ! $key;  # (F)
	
	my $rights = $c->stash("rights:$key");
	if (! $rights) {
		my @rights = $c->neo4j->session->run($Q->{may}, code => $key);
		my %rights = map { $_->get => 1 } @rights;
		$rights = \%rights;
		$c->stash("rights:$key" => $rights);
		
#		say "$key rights:";
#		say Data::Dumper::Dumper $rights;
	}
	return $USER_ACCESS if $rights->{$right};  # (F)
	
	# (G):
	return $NO_ACCESS if ! $entity;
	my $exceptions = $c->stash("entity_exceptions:$key");
	if (! $exceptions) {
		my @exceptions = $c->neo4j->session->run($Q->{entity_exceptions}, code => $key);
		my %exceptions = map { $_->get => $_->get(1) || 1 } @exceptions;
		$exceptions = \%exceptions;
		$c->stash("entity_exceptions:$key" => $exceptions);
		
#		say "$key entity exceptions:";
#		say Data::Dumper::Dumper $exceptions;
	}
	return $USER_ACCESS if $exceptions->{$entity};  # (G)
	
	return $NO_ACCESS;
}


sub __may_wiki {
	my ($c, $wikicommand, $slug, $key) = @_;
	$wikicommand ||= 'view';
	$key ||= $c->session('key');
	return $OPEN_ACCESS if ! $slug;
#	print "may_wiki: $wikicommand:$slug";
	
	# cache role requirements of Wiki articles to minimise expensive database roundtrips
	my $wikiroles = $c->stash("wikiroles");
	if (! $wikiroles) {
		my @wikiroles = $c->neo4j->session->run($Q->{wikiroles});
		my %wikiroles = map { $_->get('slug') => $_->get('role') } @wikiroles;
		$wikiroles = \%wikiroles;
		$c->stash("wikiroles" => $wikiroles);
	}
	my $roles = $wikiroles->{$slug};
	
	# truth table Wiki access:
	#  A B C D => access
	#  0 - 1 - =>  open
	#  0 - 0 1 =>  user
	#  0 - 0 0 =>   no
	#  1 0 - - =>   no
	#  1 1 1 - =>  user
	#  1 1 - 1 =>  user
	# (A) = ARTICLE has role requirements
	# (B) = USER satisfies the ARTICLE's role requirements
	# (C) = COMMAND is 'view'
	# (D) = USER has role for route of current COMMAND
	
	if ($roles) {  # (A)
#		$role = "mojo:$role" if $role =~ m/^wiki[a-z]*$/;  # prevent recursion if database is corrupt
		return $NO_ACCESS if ! grep { $c->skgb->_may_mojo($_, $key) } @$roles;  # (B)
		return $USER_ACCESS if $wikicommand eq 'view';  # (C)
	}
	else {
		return $OPEN_ACCESS if $wikicommand eq 'view';  # (C)
	}
	return $USER_ACCESS if $c->skgb->_may_mojo("mojo:wiki$wikicommand", $key);  # (D)
	return $NO_ACCESS;
}


# $c->auth_link_to person => $person->name, {entity => $person->handle}
# $c->auth_link_to "$wikicommand:$slug" => $title
sub _auth_link_to {
	my ($c, $linktarget, $linktext, $params) = @_;
	$linktarget =~ m/^(?:([a-z]+):)?(.+)$/ or return $linktext;
	my $wikicommand = $1 // "mojo";
	my $linkdest = $2;
	my $route = $linkdest;
	my $entity = $params->{entity};
	if ($wikicommand ne "mojo") {
		$route = "wiki$wikicommand";
		$entity = SKGB::Intern::Article->normalise_slug($linkdest);
	}
#	say "auth_link_to: $route ($entity)";
	
	my $html = $c->render_to_string('link',
		access   => $c->skgb->may("mojo:$route", undef, $entity),
		session  => !! $c->skgb->session,
		linkurl  => $c->url_for($route, entity => $entity, %$params),
		linktext => $linktext,
		showicon => 1,
	);
	$$html = substr $$html, 0, -1;  # remove trailing line break
	return $html;
}


sub _link_auth_to {
	my ($c, $content) = (shift, shift);
	my @url = ($content);
	
	# Content/Captures logic lifted straight from _link_to helper in Mojo 6.37
	
	# Content
	unless (ref $_[-1] eq 'CODE') {
		@url = (shift);
		push @_, $content;
	}
	
	# Captures
	push @url, shift if ref $_[0] eq 'HASH';
	
	$c->app->log->info('link_auth_to deprecated');
	
	# check auth
	return $c->auth_link_to("mojo:$url[0]", $_[0]->());
#	my $url = $c->skgb->_link_url("mojo", @url);
#	my $restricted = ! $c->skgb->may("mojo:$url[0]");
#	return $c->tag('a', class => 'no-access', @_) if $restricted;
#	return $c->tag('a', href => $url, @_);
}


sub _reset_login_fails {
	my ($self, $c, %options) = @_;
	
	my $config = $c->app->config->{login_fails};
	my $t = $c->app->neo4j->session->begin_transaction;
	$t->{return_stats} = 1;
	my $record = $t->run(<<_)->single;
MATCH (s:System)
RETURN s.shortLoginFails, s.longLoginFails, s.shortLoginReset, s.longLoginReset
_
	$options{force} and say "*** Force Login Fail Reset ***";
	
	my $short_reset = $self->_do_reset_login_fails(
		$record->get('s.shortLoginReset'),
		$record->get('s.shortLoginFails'),
		"min" => 60,
		$config->{short_time},
		$config->{short_limit},
		$options{force},
		$t => 'MATCH (s:System) SET s.shortLoginFails = 0, s.shortLoginReset = {now}',
	);
	my $long_reset = $self->_do_reset_login_fails(
		$record->get('s.longLoginReset'),
		$record->get('s.longLoginFails'),
		" hr" => 3600,
		$config->{long_time},
		$config->{long_limit},
		$options{force},
		$t => 'MATCH (s:System) SET s.longLoginFails = 0, s.longLoginReset = {now}',
	);
	$t->commit;
	if ($short_reset || $long_reset) {
		print "Login fail reset done (", $short_reset ? "short" : "";
		print " and " if $short_reset && $long_reset;
		print $long_reset ? "long" : "", ")\n";
	}
}


sub _do_reset_login_fails {
	my ($self, $reset_time, $fail_count, $unit => $unit_seconds, $time_limit, $rate_limit, $force_reset, $t => $reset_query) = @_;
	
	my $reset = ! $reset_time;
	printf "%2d login fail%s %s", $fail_count, $fail_count != 1 ? "s" : " ", $reset_time ? "" : "(";
	if ($reset_time) {
		my $time_diff = time - DateTime::Format::ISO8601->parse_datetime($reset_time)->epoch;  # in seconds
		$reset = $time_diff >= $time_limit * .97 - 1;  # cron isn't always executed at the exact same second, so we choose to reset even if we're a little early
		my $rate = sprintf "%.1f", $fail_count / $time_diff * $unit_seconds;
		$time_diff = sprintf "%4.1f", $time_diff / $unit_seconds;  # in given unit
		printf "in last $time_diff $unit%s (rate $rate /$unit, ", $time_diff != 1 ? "s" : " ";
	}
	$rate_limit = sprintf "%.1f", $rate_limit / $time_limit * $unit_seconds;
	$time_limit = sprintf "%4.1f", $time_limit / $unit_seconds;
	printf "limit $rate_limit /$unit for $time_limit $unit%s)\n", $time_limit != 1 ? "s" : " ";
	if ($force_reset || $reset) {
		my $result = $t->run($reset_query, now => SKGB::Intern::AccessCode::new_time);
		$result->summary->counters->properties_set and return 1 or warn 'Login fail reset: Failed to modify database';
	}
	return 0;
}


1;
