package SKGB::Intern::Plugin::AuthManager;
use Mojo::Base 'Mojolicious::Plugin';

use utf8;

use Mojolicious 7.13;  # Mojo::Message::Response->is_success
use REST::Neo4p;
#use List::Util;
#use POSIX qw();
use Data::Dumper;

use SKGB::Intern::AccessCode;

#use Mojolicious::Plugin::Authorization;


my $Q = {
  access => REST::Neo4p::Query->new(<<END),
MATCH (c:AccessCode)-[:IDENTIFIES]->(p:Person)-[a:ROLE|GUEST|ACCESS*..3]->(r:Resource)
 WHERE c.code = {code}
 AND any(y IN r.urls WHERE {url} =~ y)
 AND coalesce(last(a).level, 1) >= toInt({level})
 AND type(last(a)) = 'ACCESS' AND single(x IN a WHERE type(x) = 'ACCESS')
 RETURN p, c, r, last(a)
 ORDER BY last(a).level DESC
 LIMIT 1
END
#   may => <<END,
# MATCH (c:AccessCode)-[:IDENTIFIES]->(:Person)-[:IS_A|IS_A_GUEST*..2]->(:Role)-[:MAY]->(s:Right)
#  WHERE c.code = {code}
#  RETURN s.right
# END
  may => <<_,
MATCH (c:AccessCode)-[:IDENTIFIES]->(:Person)-[:ROLE|GUEST*..3]->(r:Role)-[:MAY]->(s:Right)
WHERE c.code = {code} AND NOT( (c)-[:NOT]->(r) )
RETURN s.right
UNION
MATCH (c:AccessCode)-[:ROLE*..3]->(r:Role)-[:MAY]->(s:Right)
WHERE c.code = {code}
RETURN s.right
_
  role => <<_,
MATCH (c:AccessCode)-[:IDENTIFIES]->(:Person)-[:ROLE|GUEST*..3]->(r:Role)
WHERE c.code = {code} AND r.role = {role} AND NOT( (c)-[:NOT]->(r) )
RETURN true AS has_role
UNION
MATCH (c:AccessCode)-[:ROLE*..3]->(r:Role)
WHERE c.code = {code} AND r.role = {role}
RETURN true AS has_role
_
};


sub register {
	my ($self, $app, $args) = @_;
	$args ||= {};
	
	$app->sessions->default_expiration( $app->config->{ttl}->{cookie} );
	$app->sessions->cookie_name('SKGB-intern');
	$app->sessions->secure($app->mode ne 'development');  # deployment: HTTPS only
	
	# As a rule, none of the responses generated by this application are
	# cacheable because all of them might or might not be personalized,
	# depending upon the session cookie among other things.
	$app->hook(after_dispatch => sub {
		my ($c, $args) = @_;
		# HTTP: RFCs 7231, 7234
		
		# make sure public static files are cacheable
		my $content = $c->res->content;
		if (ref $content eq 'Mojo::Content::Single' && ref $content->asset eq 'Mojo::Asset::File') {
			if ( grep {$content->asset->path =~ m|^$_/|} @{$app->static->paths} ) {
				$c->res->headers->cache_control('public');  # mostly useless
				return;  # very important
			}
		}
		
		# advertise authentication
		# NB: X-Cookie is not a registered new auth scheme and will hopefully remain so; this header should never trigger any kind of special treatment by the user agent
		# see http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml
		# see http://tools.ietf.org/html/draft-broyer-http-cookie-auth-00
		$c->res->headers->www_authenticate('X-Cookie');
		
		if ($app->sessions->default_expiration) {
			# in the current Mojo implementation the cookie includes the ever-changing expiration time, thereby precluding hits while filling up the cache
			$c->res->headers->cache_control('no-cache');
			$c->res->headers->header(Pragma => 'no-cache');  # HTTP/1.0 fallback
		}
		else {
			# session cookies only include the access code, which is static and which primarily decides what gets rendered
			$c->res->headers->vary('cookie');
			if ($c->skgb->session->user) {
				# 'private' disallows shared caches and 'no-store' disallows storage on disk, leaving nothing but in-memory browser cache (for data protection)
				$c->res->headers->cache_control('private, no-store');
				$c->res->headers->header(Pragma => 'no-cache');  # HTTP/1.0 fallback
			}
			elsif ($c->res->is_success) {
				# 'public' explicitly allows caching, which is useful for public content (except maybe for error pages)
				$c->res->headers->cache_control('public');
			}
		}
	});
	
	my @helpers = qw( link_auth_to has_access );
	$app->helper($_ => __PACKAGE__->can("_$_")) for @helpers;
	
	my @skgb_helpers = qw( session may role );
	$app->helper("skgb.$_" => __PACKAGE__->can("_$_")) for @skgb_helpers;
	
}


# Get the AccessCode object AKA 'session hash'. A key parameter may be given to
# use that specific key in lieu of the current session; this is required when
# logging in.
# Also sets/refreshes the session cookie. To be called on every access.
sub _session {
	my ($c, $key) = @_;
	$key ||= $c->session('key');
	
	my $session = $c->stash('session');
	if (! $session) {
		$session = SKGB::Intern::AccessCode->new( code => $key, app => $c );
		if ($session->user) {
			$session->update;
			$c->session( key => $key );
		}
		$c->stash(session => $session);
	}
	
	return $session;
}


sub _may {
	my ($c, $right, $key) = @_;
	$key ||= $c->session('key');
	return undef if ! $key;
	$right ||= "mojo:" . $c->current_route;
	
	my $rights = $c->stash('rights');
	if (! $rights) {
		my @rights = $c->neo4j->session->run($Q->{may}, code => $key);
		my %rights = map { $_->get => 1 } @rights;
		$rights = \%rights;
		$c->stash(rights => $rights);
		
#		say "$key:";
#		say Data::Dumper::Dumper $rights;
	}
	
	return $rights->{$right};
}


# this may be a dirty hack (initially only used to 'simplify' a provisional check in the Stegdienstliste app)
sub _role {
	my ($c, $role, $key) = @_;
	$key ||= $c->session('key');
	return undef if ! $key;
	
	my $result = $c->neo4j->session->run($Q->{role}, code => $key, role => $role);
	return $result->size;
}


# sub _if_may {
# 	my ($c, $right, $then) = @_;
# 	
# 	if (ref $then) {
# 		# not implemented
# 		die;
# 	}
# 	
# 	return $c->skgb->may($right) ? $then : "ğŸ”’";
# }


sub _link_auth_to {
	my ($c, $content) = (shift, shift);
	my @url = ($content);
	
	# Content/Captures logic lifted straight from _link_to helper in Mojo 6.37
	
	# Content
	unless (ref $_[-1] eq 'CODE') {
		@url = (shift);
		push @_, $content;
	}
	
	# Captures
	push @url, shift if ref $_[0] eq 'HASH';
	
	# check auth
	my $url = $c->url_for(@url);
	my $target = $url[0];
	my $access = $c->skgb->may("mojo:$target");
	if (! $access) {
		my $routes = $c->app->routes;
		my $route = $routes->lookup($target);
		$access = $route->parent == $routes if $route;  # top level route => no login requirement => public access
#		$access ||= $c->has_access($url) unless $target && $target eq "_";  # old URL-based scheme
	}
	return $c->tag('a', class => 'no-access', @_) if ! $access;
	
	return $c->tag('a', href => $url, @_);
}


1;
